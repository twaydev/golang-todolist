name: ai/perplexity-api
description: Perplexity AI API integration for intent classification and natural language understanding
category: ai-nlp
language: go

overview: |
  Perplexity AI provides powerful language models via API for intent classification,
  entity extraction, and natural language understanding. Perfect for parsing user
  messages like "Buy milk tomorrow" into structured todo items.

features:
  - Intent classification (create, update, delete, list)
  - Entity extraction (title, date, priority, tags)
  - Natural language date parsing
  - Multilingual support (English, Vietnamese)
  - Fast response times (<500ms)
  - Structured JSON output

api_basics: |
  Base URL: https://api.perplexity.ai
  Authentication: Bearer token in Authorization header
  Model: sonar-medium-online (recommended for intent classification)

  Available models:
  - sonar-small-chat: Fastest, lowest cost
  - sonar-medium-online: Balanced performance
  - sonar-large-online: Highest accuracy
  - codellama-70b-instruct: For code-related tasks

client_implementation: |
  package perplexity

  import (
      "bytes"
      "context"
      "encoding/json"
      "fmt"
      "io"
      "net/http"
      "time"
  )

  const (
      BaseURL = "https://api.perplexity.ai"
      DefaultModel = "sonar-medium-online"
      DefaultTimeout = 30 * time.Second
  )

  type Client struct {
      apiKey     string
      httpClient *http.Client
      model      string
  }

  func NewClient(apiKey string) *Client {
      return &Client{
          apiKey: apiKey,
          httpClient: &http.Client{
              Timeout: DefaultTimeout,
          },
          model: DefaultModel,
      }
  }

  type ChatRequest struct {
      Model       string    `json:"model"`
      Messages    []Message `json:"messages"`
      Temperature float64   `json:"temperature,omitempty"`
      MaxTokens   int       `json:"max_tokens,omitempty"`
  }

  type Message struct {
      Role    string `json:"role"` // system, user, assistant
      Content string `json:"content"`
  }

  type ChatResponse struct {
      ID      string   `json:"id"`
      Model   string   `json:"model"`
      Created int64    `json:"created"`
      Choices []Choice `json:"choices"`
      Usage   Usage    `json:"usage"`
  }

  type Choice struct {
      Index        int     `json:"index"`
      Message      Message `json:"message"`
      FinishReason string  `json:"finish_reason"`
  }

  type Usage struct {
      PromptTokens     int `json:"prompt_tokens"`
      CompletionTokens int `json:"completion_tokens"`
      TotalTokens      int `json:"total_tokens"`
  }

  func (c *Client) Chat(ctx context.Context, messages []Message) (*ChatResponse, error) {
      req := ChatRequest{
          Model:       c.model,
          Messages:    messages,
          Temperature: 0.2, // Low temperature for consistent intent classification
      }

      body, err := json.Marshal(req)
      if err != nil {
          return nil, fmt.Errorf("marshal request: %w", err)
      }

      httpReq, err := http.NewRequestWithContext(ctx, "POST", BaseURL+"/chat/completions", bytes.NewReader(body))
      if err != nil {
          return nil, err
      }

      httpReq.Header.Set("Content-Type", "application/json")
      httpReq.Header.Set("Authorization", "Bearer "+c.apiKey)

      resp, err := c.httpClient.Do(httpReq)
      if err != nil {
          return nil, fmt.Errorf("http request: %w", err)
      }
      defer resp.Body.Close()

      if resp.StatusCode != http.StatusOK {
          bodyBytes, _ := io.ReadAll(resp.Body)
          return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(bodyBytes))
      }

      var chatResp ChatResponse
      if err := json.NewDecoder(resp.Body).Decode(&chatResp); err != nil {
          return nil, fmt.Errorf("decode response: %w", err)
      }

      return &chatResp, nil
  }

intent_analyzer_implementation: |
  package perplexity

  import (
      "context"
      "encoding/json"
      "fmt"
      "time"
      
      "todobot/internal/domain/entity"
      "todobot/internal/domain/port/output"
  )

  type IntentAnalyzer struct {
      client *Client
  }

  func NewIntentAnalyzer(apiKey string) output.IntentAnalyzer {
      return &IntentAnalyzer{
          client: NewClient(apiKey),
      }
  }

  func (a *IntentAnalyzer) Analyze(
      ctx context.Context,
      message string,
      existingTodos []*entity.Todo,
      lang entity.Language,
  ) (*entity.ParsedIntent, error) {
      // Build system prompt
      systemPrompt := a.buildSystemPrompt(lang, existingTodos)
      
      // Build user message
      userPrompt := a.buildUserPrompt(message, lang)

      // Call Perplexity
      messages := []Message{
          {Role: "system", Content: systemPrompt},
          {Role: "user", Content: userPrompt},
      }

      resp, err := a.client.Chat(ctx, messages)
      if err != nil {
          return nil, fmt.Errorf("perplexity chat: %w", err)
      }

      if len(resp.Choices) == 0 {
          return nil, fmt.Errorf("no response from API")
      }

      // Parse JSON response
      content := resp.Choices[0].Message.Content
      
      var intent entity.ParsedIntent
      if err := json.Unmarshal([]byte(content), &intent); err != nil {
          // Fallback to regex parsing if JSON parsing fails
          return a.fallbackParsing(message, lang)
      }

      intent.RawMessage = message
      intent.DetectedLanguage = lang

      return &intent, nil
  }

prompt_engineering: |
  func (a *IntentAnalyzer) buildSystemPrompt(lang entity.Language, existingTodos []*entity.Todo) string {
      now := time.Now()
      
      // Build todo list context
      todoContext := ""
      if len(existingTodos) > 0 {
          todoContext = "\nExisting todos:\n"
          for _, todo := range existingTodos {
              todoContext += fmt.Sprintf("- %s: %s (status: %s)\n", todo.Code, todo.Title, todo.Status)
          }
      }

      systemPrompt := fmt.Sprintf(`You are a todo assistant that parses natural language into structured intents.

Current Context:
- Today's date: %s
- Day of week: %s
- User's language: %s%s

Your task is to analyze the user's message and extract:
1. Action: create, update, delete, complete, list, search, help, unknown
2. Title: Task title (if creating/updating)
3. Due date: Parse relative dates (tomorrow, next week, etc.)
4. Priority: Detect keywords:
   - English: urgent, important, asap, high priority → high
   - Vietnamese: gấp, khẩn cấp, quan trọng, ưu tiên cao → high
   - Default: medium
5. Tags: Extract hashtags (#work, #urgent) or keywords
6. Todo reference: Match code (YY-NNNN) or partial title
7. Confidence: 0.0-1.0 based on clarity

Date Parsing Rules:
- English: "tomorrow" → %s, "next week" → %s, "monday" → next Monday
- Vietnamese: "ngày mai" → %s, "tuần sau" → %s, "thứ hai" → next Monday

Output valid JSON only (no explanation):
{
  "action": "create",
  "data": {
    "title": "Buy milk",
    "due_date": "%s",
    "priority": "medium",
    "tags": ["shopping"]
  },
  "confidence": 0.95
}

If the intent is ambiguous or you're unsure, return:
{
  "action": "unknown",
  "confidence": 0.3,
  "ambiguities": ["unclear if this is create or update", "which todo to modify?"]
}`,
          now.Format("2006-01-02"),
          now.Format("Monday"),
          lang,
          todoContext,
          now.AddDate(0, 0, 1).Format("2006-01-02"),
          now.AddDate(0, 0, 7).Format("2006-01-02"),
          now.AddDate(0, 0, 1).Format("2006-01-02"),
          now.AddDate(0, 0, 7).Format("2006-01-02"),
          now.AddDate(0, 0, 1).Format("2006-01-02T15:04:05Z07:00"),
      )

      return systemPrompt
  }

  func (a *IntentAnalyzer) buildUserPrompt(message string, lang entity.Language) string {
      return fmt.Sprintf(`Parse this %s message: "%s"`, lang, message)
  }

fallback_parsing: |
  func (a *IntentAnalyzer) fallbackParsing(message string, lang entity.Language) (*entity.ParsedIntent, error) {
      // Regex-based fallback when API fails or returns invalid JSON
      message = strings.ToLower(strings.TrimSpace(message))

      intent := &entity.ParsedIntent{
          Action:           entity.ActionUnknown,
          Data:             entity.IntentData{},
          Confidence:       0.5,
          DetectedLanguage: lang,
          RawMessage:       message,
      }

      // Detect action
      if lang == entity.LangEnglish {
          if strings.Contains(message, "list") || strings.Contains(message, "show") {
              intent.Action = entity.ActionList
              intent.Confidence = 0.8
              return intent, nil
          }
          if strings.Contains(message, "done") || strings.Contains(message, "complete") {
              intent.Action = entity.ActionComplete
              intent.Confidence = 0.7
          } else {
              // Default to create
              intent.Action = entity.ActionCreate
              title := message
              intent.Data.Title = &title
          }
      } else if lang == entity.LangVietnamese {
          if strings.Contains(message, "danh sách") || strings.Contains(message, "xem") {
              intent.Action = entity.ActionList
              intent.Confidence = 0.8
              return intent, nil
          }
          if strings.Contains(message, "xong") || strings.Contains(message, "hoàn thành") {
              intent.Action = entity.ActionComplete
              intent.Confidence = 0.7
          } else {
              // Default to create
              intent.Action = entity.ActionCreate
              title := message
              intent.Data.Title = &title
          }
      }

      // Extract priority keywords
      priority := entity.PriorityMedium
      if lang == entity.LangEnglish {
          if containsAny(message, []string{"urgent", "asap", "important", "high priority"}) {
              priority = entity.PriorityHigh
          } else if containsAny(message, []string{"low priority", "someday", "whenever"}) {
              priority = entity.PriorityLow
          }
      } else if lang == entity.LangVietnamese {
          if containsAny(message, []string{"gấp", "khẩn cấp", "quan trọng", "ưu tiên cao"}) {
              priority = entity.PriorityHigh
          }
      }
      intent.Data.Priority = &priority

      // Extract tags (hashtags)
      tags := extractHashtags(message)
      if len(tags) > 0 {
          intent.Data.Tags = tags
      }

      return intent, nil
  }

  func containsAny(text string, keywords []string) bool {
      for _, keyword := range keywords {
          if strings.Contains(text, keyword) {
              return true
          }
      }
      return false
  }

  func extractHashtags(message string) []string {
      words := strings.Fields(message)
      var tags []string
      for _, word := range words {
          if strings.HasPrefix(word, "#") {
              tag := strings.TrimPrefix(word, "#")
              tag = strings.TrimSuffix(tag, ",")
              tag = strings.TrimSuffix(tag, ".")
              if tag != "" {
                  tags = append(tags, tag)
              }
          }
      }
      return tags
  }

error_handling_and_retry: |
  package perplexity

  import (
      "context"
      "time"
  )

  // Retry with exponential backoff
  func (c *Client) ChatWithRetry(ctx context.Context, messages []Message, maxRetries int) (*ChatResponse, error) {
      var lastErr error
      
      for i := 0; i < maxRetries; i++ {
          resp, err := c.Chat(ctx, messages)
          if err == nil {
              return resp, nil
          }
          
          lastErr = err
          
          // Exponential backoff
          if i < maxRetries-1 {
              backoff := time.Duration(1<<uint(i)) * time.Second
              select {
              case <-time.After(backoff):
              case <-ctx.Done():
                  return nil, ctx.Err()
              }
          }
      }
      
      return nil, fmt.Errorf("max retries exceeded: %w", lastErr)
  }

  // Circuit breaker pattern
  type CircuitBreaker struct {
      maxFailures  int
      resetTimeout time.Duration
      failures     int
      lastFailure  time.Time
      state        string // "closed", "open", "half-open"
  }

  func NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
      return &CircuitBreaker{
          maxFailures:  maxFailures,
          resetTimeout: resetTimeout,
          state:        "closed",
      }
  }

  func (cb *CircuitBreaker) Call(fn func() error) error {
      if cb.state == "open" {
          if time.Since(cb.lastFailure) > cb.resetTimeout {
              cb.state = "half-open"
          } else {
              return fmt.Errorf("circuit breaker is open")
          }
      }

      err := fn()
      
      if err != nil {
          cb.failures++
          cb.lastFailure = time.Now()
          
          if cb.failures >= cb.maxFailures {
              cb.state = "open"
          }
          return err
      }

      // Success
      if cb.state == "half-open" {
          cb.state = "closed"
          cb.failures = 0
      }
      
      return nil
  }

caching: |
  package perplexity

  import (
      "crypto/sha256"
      "encoding/hex"
      "sync"
      "time"
  )

  type CachedIntent struct {
      Intent    *entity.ParsedIntent
      ExpiresAt time.Time
  }

  type IntentCache struct {
      cache map[string]*CachedIntent
      mu    sync.RWMutex
      ttl   time.Duration
  }

  func NewIntentCache(ttl time.Duration) *IntentCache {
      cache := &IntentCache{
          cache: make(map[string]*CachedIntent),
          ttl:   ttl,
      }
      
      // Cleanup expired entries periodically
      go cache.cleanup()
      
      return cache
  }

  func (c *IntentCache) Get(message string, lang entity.Language) (*entity.ParsedIntent, bool) {
      c.mu.RLock()
      defer c.mu.RUnlock()
      
      key := c.cacheKey(message, lang)
      
      cached, ok := c.cache[key]
      if !ok {
          return nil, false
      }
      
      if time.Now().After(cached.ExpiresAt) {
          return nil, false
      }
      
      return cached.Intent, true
  }

  func (c *IntentCache) Set(message string, lang entity.Language, intent *entity.ParsedIntent) {
      c.mu.Lock()
      defer c.mu.Unlock()
      
      key := c.cacheKey(message, lang)
      
      c.cache[key] = &CachedIntent{
          Intent:    intent,
          ExpiresAt: time.Now().Add(c.ttl),
      }
  }

  func (c *IntentCache) cacheKey(message string, lang entity.Language) string {
      data := message + string(lang)
      hash := sha256.Sum256([]byte(data))
      return hex.EncodeToString(hash[:])
  }

  func (c *IntentCache) cleanup() {
      ticker := time.NewTicker(5 * time.Minute)
      defer ticker.Stop()
      
      for range ticker.C {
          c.mu.Lock()
          now := time.Now()
          for key, cached := range c.cache {
              if now.After(cached.ExpiresAt) {
                  delete(c.cache, key)
              }
          }
          c.mu.Unlock()
      }
  }

testing: |
  package perplexity

  import (
      "context"
      "testing"
      "github.com/stretchr/testify/assert"
      "github.com/stretchr/testify/require"
  )

  func TestIntentAnalyzer_Analyze_CreateTodo(t *testing.T) {
      // Skip if no API key
      apiKey := os.Getenv("PERPLEXITY_API_KEY")
      if apiKey == "" {
          t.Skip("PERPLEXITY_API_KEY not set")
      }

      analyzer := NewIntentAnalyzer(apiKey)

      tests := []struct {
          name            string
          message         string
          lang            entity.Language
          expectedAction  entity.ActionType
          expectedTitle   string
          minConfidence   float64
      }{
          {
              name:           "Simple create in English",
              message:        "Buy groceries",
              lang:           entity.LangEnglish,
              expectedAction: entity.ActionCreate,
              expectedTitle:  "Buy groceries",
              minConfidence:  0.8,
          },
          {
              name:           "Create with date",
              message:        "Buy milk tomorrow",
              lang:           entity.LangEnglish,
              expectedAction: entity.ActionCreate,
              expectedTitle:  "Buy milk",
              minConfidence:  0.8,
          },
          {
              name:           "Create in Vietnamese",
              message:        "Mua rau ngày mai",
              lang:           entity.LangVietnamese,
              expectedAction: entity.ActionCreate,
              expectedTitle:  "Mua rau",
              minConfidence:  0.7,
          },
      }

      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              intent, err := analyzer.Analyze(context.Background(), tt.message, nil, tt.lang)
              
              require.NoError(t, err)
              assert.Equal(t, tt.expectedAction, intent.Action)
              assert.GreaterOrEqual(t, intent.Confidence, tt.minConfidence)
              
              if tt.expectedTitle != "" {
                  require.NotNil(t, intent.Data.Title)
                  assert.Contains(t, *intent.Data.Title, tt.expectedTitle)
              }
          })
      }
  }

best_practices:
  - Use low temperature (0.1-0.3) for consistent intent classification
  - Cache common queries to reduce API calls
  - Implement fallback regex parsing for API failures
  - Use circuit breaker pattern to handle API outages
  - Set appropriate timeouts (5-10 seconds)
  - Provide clear system prompts with examples
  - Include context (existing todos, current date)
  - Validate and sanitize API responses
  - Monitor API usage and costs
  - Log failed parses for improvement

common_patterns:
  with_context: |
    // Pass existing todos for better ambiguity resolution
    todos, _ := todoRepo.List(ctx, userID, filters)
    intent, err := intentAnalyzer.Analyze(ctx, message, todos, lang)
  
  with_caching: |
    // Check cache first
    if cached, ok := cache.Get(message, lang); ok {
        return cached, nil
    }
    
    // Call API
    intent, err := analyzer.Analyze(ctx, message, todos, lang)
    if err == nil {
        cache.Set(message, lang, intent)
    }
    return intent, err

troubleshooting:
  invalid_json: |
    Problem: API returns invalid JSON
    Solution: Implement fallback regex parsing
    - Check if response starts with ```json
    - Strip markdown code blocks
    - Use fallbackParsing() as backup
  
  timeout: |
    Problem: API requests timeout
    Solution:
    - Increase timeout: httpClient.Timeout = 30 * time.Second
    - Implement retry with backoff
    - Use circuit breaker pattern
  
  low_accuracy: |
    Problem: Intent parsing is inaccurate
    Solution:
    - Improve system prompt with more examples
    - Provide better context (existing todos, date)
    - Use higher-tier model (sonar-large-online)
    - Fine-tune with custom examples

resources:
  documentation: https://docs.perplexity.ai/
  api_reference: https://docs.perplexity.ai/reference/post_chat_completions
  pricing: https://docs.perplexity.ai/docs/pricing
  models: https://docs.perplexity.ai/docs/model-cards
