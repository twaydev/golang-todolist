name: mocking/mockery
description: Automatic mock generation for Go interfaces using testify/mock
category: testing
language: go

overview: |
  Mockery automatically generates mock implementations of Go interfaces for
  use with testify/mock. It eliminates the need to manually write mock
  implementations, ensuring mocks stay in sync with interface changes.

installation: |
  # Install globally
  go install github.com/vektra/mockery/v2@latest
  
  # Or add to project
  go get github.com/vektra/mockery/v2

configuration: |
  # .mockery.yaml (project root)
  with-expecter: true
  dir: "test/mocks"
  outpkg: "mocks"
  packageprefix: ""
  filename: "mock_{{.InterfaceName}}.go"
  
  packages:
    github.com/yourusername/todobot/internal/domain/port/output:
      interfaces:
        TodoRepository:
        UserRepository:
        IntentAnalyzer:
        Notifier:

example_interface: |
  // internal/domain/port/output/todo_repository.go
  package output

  import (
      "context"
      "todobot/internal/domain/entity"
  )

  type TodoRepository interface {
      Create(ctx context.Context, todo *entity.Todo) error
      Update(ctx context.Context, todo *entity.Todo) error
      Delete(ctx context.Context, userID int64, todoID string) error
      GetByID(ctx context.Context, userID int64, todoID string) (*entity.Todo, error)
      GetByCode(ctx context.Context, userID int64, code string) (*entity.Todo, error)
      List(ctx context.Context, userID int64, filters ListFilters) ([]*entity.Todo, error)
      Search(ctx context.Context, userID int64, query string) ([]*entity.Todo, error)
  }

generating_mocks: |
  # Generate all mocks
  mockery --all --dir=internal/domain/port/output --output=test/mocks --outpkg=mocks
  
  # Generate specific interface
  mockery --name=TodoRepository --dir=internal/domain/port/output --output=test/mocks
  
  # Using config file
  mockery
  
  # With expecter pattern (recommended)
  mockery --with-expecter --name=TodoRepository

generated_mock: |
  // test/mocks/mock_TodoRepository.go
  // Code generated by mockery. DO NOT EDIT.

  package mocks

  import (
      context "context"
      entity "todobot/internal/domain/entity"
      output "todobot/internal/domain/port/output"
      
      mock "github.com/stretchr/testify/mock"
  )

  // MockTodoRepository is an autogenerated mock type for the TodoRepository type
  type MockTodoRepository struct {
      mock.Mock
  }

  type MockTodoRepository_Expecter struct {
      mock *mock.Mock
  }

  func (_m *MockTodoRepository) EXPECT() *MockTodoRepository_Expecter {
      return &MockTodoRepository_Expecter{mock: &_m.Mock}
  }

  // Create provides a mock function with given fields: ctx, todo
  func (_m *MockTodoRepository) Create(ctx context.Context, todo *entity.Todo) error {
      ret := _m.Called(ctx, todo)
      return ret.Error(0)
  }

  // Create_Call is a helper for calling Create with expecter pattern
  type MockTodoRepository_Create_Call struct {
      *mock.Call
  }

  func (_e *MockTodoRepository_Expecter) Create(ctx interface{}, todo interface{}) *MockTodoRepository_Create_Call {
      return &MockTodoRepository_Create_Call{Call: _e.mock.On("Create", ctx, todo)}
  }

  func (_c *MockTodoRepository_Create_Call) Run(run func(ctx context.Context, todo *entity.Todo)) *MockTodoRepository_Create_Call {
      _c.Call.Run(func(args mock.Arguments) {
          run(args[0].(context.Context), args[1].(*entity.Todo))
      })
      return _c
  }

  func (_c *MockTodoRepository_Create_Call) Return(_a0 error) *MockTodoRepository_Create_Call {
      _c.Call.Return(_a0)
      return _c
  }

  // GetByID provides a mock function
  func (_m *MockTodoRepository) GetByID(ctx context.Context, userID int64, todoID string) (*entity.Todo, error) {
      ret := _m.Called(ctx, userID, todoID)
      
      var r0 *entity.Todo
      if rf, ok := ret.Get(0).(func(context.Context, int64, string) *entity.Todo); ok {
          r0 = rf(ctx, userID, todoID)
      } else {
          if ret.Get(0) != nil {
              r0 = ret.Get(0).(*entity.Todo)
          }
      }
      
      var r1 error
      if rf, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
          r1 = rf(ctx, userID, todoID)
      } else {
          r1 = ret.Error(1)
      }
      
      return r0, r1
  }

using_generated_mocks: |
  // test/unit/domain/todo_service_test.go
  package domain

  import (
      "context"
      "testing"
      
      "github.com/stretchr/testify/assert"
      "github.com/stretchr/testify/mock"
      "github.com/stretchr/testify/require"
      
      "todobot/internal/domain/entity"
      "todobot/internal/domain/service"
      "todobot/test/mocks"
  )

  func TestTodoService_CreateTodo_Success(t *testing.T) {
      // Arrange
      mockRepo := mocks.NewMockTodoRepository(t)
      mockUserRepo := mocks.NewMockUserRepository(t)
      
      svc := service.NewTodoService(mockRepo, mockUserRepo, nil, nil)
      
      // Set up expectations (traditional style)
      mockRepo.On("Create", mock.Anything, mock.MatchedBy(func(todo *entity.Todo) bool {
          return todo.Title == "Buy milk"
      })).Return(nil)
      
      // Act
      todo, err := svc.CreateTodo(context.Background(), 123, "Buy milk", nil)
      
      // Assert
      require.NoError(t, err)
      assert.Equal(t, "Buy milk", todo.Title)
      
      // Verify all expectations met
      mockRepo.AssertExpectations(t)
  }

  func TestTodoService_CreateTodo_WithExpecterPattern(t *testing.T) {
      // Arrange
      mockRepo := mocks.NewMockTodoRepository(t)
      mockUserRepo := mocks.NewMockUserRepository(t)
      
      svc := service.NewTodoService(mockRepo, mockUserRepo, nil, nil)
      
      // Set up expectations (expecter style - more type-safe)
      mockRepo.EXPECT().
          Create(mock.Anything, mock.MatchedBy(func(todo *entity.Todo) bool {
              return todo.Title == "Buy milk" && todo.Status == entity.StatusPending
          })).
          Run(func(ctx context.Context, todo *entity.Todo) {
              // Simulate repository assigning ID and code
              todo.ID = "todo-123"
              todo.Code = "26-0001"
          }).
          Return(nil).
          Once()  // Expect exactly one call
      
      // Act
      todo, err := svc.CreateTodo(context.Background(), 123, "Buy milk", nil)
      
      // Assert
      require.NoError(t, err)
      assert.Equal(t, "Buy milk", todo.Title)
      assert.Equal(t, "todo-123", todo.ID)
      assert.Equal(t, "26-0001", todo.Code)
      
      // Expectations verified automatically at end of test
  }

advanced_patterns:
  multiple_return_values: |
    // Setup
    mockRepo.EXPECT().
        GetByID(mock.Anything, int64(123), "todo-1").
        Return(&entity.Todo{ID: "todo-1", Title: "Test"}, nil)
    
    // Test
    todo, err := mockRepo.GetByID(ctx, 123, "todo-1")
    require.NoError(t, err)
    assert.Equal(t, "todo-1", todo.ID)
  
  conditional_returns: |
    // Return different values on different calls
    mockRepo.EXPECT().
        GetByID(mock.Anything, mock.Anything, mock.Anything).
        Return(nil, errors.New("not found")).
        Once()
    
    mockRepo.EXPECT().
        GetByID(mock.Anything, mock.Anything, mock.Anything).
        Return(&entity.Todo{}, nil).
        Maybe()  // May or may not be called
  
  custom_matchers: |
    mockRepo.EXPECT().
        Create(mock.Anything, mock.MatchedBy(func(todo *entity.Todo) bool {
            // Custom validation logic
            return len(todo.Title) > 0 && len(todo.Title) <= 500
        })).
        Return(nil)
  
  callback_functions: |
    mockRepo.EXPECT().
        Create(mock.Anything, mock.Anything).
        Run(func(ctx context.Context, todo *entity.Todo) {
            // Simulate side effects
            todo.ID = uuid.New().String()
            todo.CreatedAt = time.Now()
        }).
        Return(nil)
  
  panic_simulation: |
    mockRepo.EXPECT().
        Create(mock.Anything, mock.Anything).
        Panic("database connection failed")

makefile_integration: |
  # Makefile
  .PHONY: mocks mocks-clean mocks-verify

  # Generate all mocks
  mocks:
  	@echo "Generating mocks..."
  	mockery --config .mockery.yaml
  	@echo "Mocks generated successfully"

  # Clean generated mocks
  mocks-clean:
  	rm -rf test/mocks

  # Regenerate mocks
  mocks-regen: mocks-clean mocks

  # Verify mocks are up to date
  mocks-verify:
  	mockery --config .mockery.yaml --dry-run

github_actions_integration: |
  # .github/workflows/ci.yml
  name: CI
  
  jobs:
    test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Set up Go
          uses: actions/setup-go@v5
          with:
            go-version: '1.22'
        
        - name: Install mockery
          run: go install github.com/vektra/mockery/v2@latest
        
        - name: Generate mocks
          run: make mocks
        
        - name: Run tests
          run: go test -v -race ./...

best_practices:
  - Generate mocks as part of build process (make mocks)
  - Commit generated mocks to version control (team consistency)
  - Use .mockery.yaml for configuration (project-level settings)
  - Use expecter pattern for type safety (--with-expecter flag)
  - Always call AssertExpectations() or use testify/suite
  - Use Mock.MatchedBy for complex argument validation
  - Mock at interface boundaries (ports, not implementations)
  - Keep mocks focused (one interface per mock)

troubleshooting:
  mock_not_found: |
    Error: undefined: mocks.MockTodoRepository
    Solution: Run `make mocks` to generate mock files
  
  wrong_number_of_arguments: |
    Error: wrong number of arguments in call to mock.On
    Solution: Check interface signature matches mock setup
  
  unexpected_call: |
    Error: FAIL: unexpected call to Create(...)
    Solution: Add expectation for the call or use Maybe()
  
  missing_expectation: |
    Error: mock: expected call to Create but got none
    Solution: Ensure code actually calls the mocked method

common_mistakes:
  - Forgetting to regenerate mocks after interface changes
  - Not calling AssertExpectations() at end of test
  - Using mock.Anything when specific values should be checked
  - Over-mocking (mocking too many dependencies)
  - Testing mock behavior instead of business logic

integration_with:
  - testify/mock (underlying mock framework)
  - testify/assert (assertion helpers)
  - testify/suite (test suite helpers)
  - go generate (automatic generation with //go:generate)
  - CI/CD pipelines (automated mock generation)

resources:
  github: https://github.com/vektra/mockery
  documentation: https://vektra.github.io/mockery/
  examples: https://github.com/vektra/mockery/tree/master/examples
